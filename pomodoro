#!/usr/bin/env python3

"""
Simple Pomodoro app inspired by https://github.com/rkashapov/i3blocks-pomodoro
The app designed to be used with i3blocks.
"""

import os
import sys
import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from pathlib import Path
import datetime
from subprocess import call
from time import sleep

STATE_FILE = '/tmp/i3blocks_pomodoro.state'



class Cycle:
    def __init__(self, items):
        self._items = items
        self._iter = None
        self.reset()

    def reset(self):
        self._iter = cycle(self._items)

    def __iter__(self):
        return self

    def __next__(self):
        return next(self._iter)


class Pomodoro:
    def __init__(self, cycle):
        self._cycle = cycle
        self._state = "Paused"
        self._remaining = 0
        self._do_reset = False
        self._running = False

    @property
    def state(self):
        state = self._state
        if not self._running:
            state = "Paused"
        minutes, seconds = divmod(self._remaining, 60)
        return "{0} {1:02d}:{2:02d}".format(state, minutes, seconds)

    def toggle(self):
        self._running = not self._running

    def reset(self):
        self._do_reset = True
        self._cycle.reset()

    def start(self):
        for timeout, state, message in self._cycle:
            if self._do_reset:
                self._do_reset = False

            if self._running:
                self._state = state
                notify(message)

            self._remaining = timeout * 60
            while self._remaining:
                if self._do_reset:
                    break
                sleep(1)
                if self._running:
                    self._remaining -= 1
                    self._state = state


def emit(full_text, short_text, color, background=None, flush=True):
    d = {
        'full_text': full_text,
        'short_text': short_text,
        'color': color,
    }
    if background:
        d['background'] = background
    print(json.dumps(d), flush=flush)

def err(text):
    print(text, file=sys.stderr, flush=False)


def notify(text):
    call(["notify-send", "Pomodoro", text])


def _now() -> int:
    return int(datetime.datetime.now().timestamp())


@dataclass
class State:
    started: int = field(default_factory=_now)
    stage: int = 0
    since_started: Optional[int] = None

    def update_from_json(self, path: Path):
        if isinstance(path, str):
            path = Path(path)
        if path.is_file():
            self.__dict__.update(json.loads(path.read_text()))

    def to_json(self, path: Path):
        if isinstance(path, str):
            path = Path(path)
        path.write_text(json.dumps(self.__dict__, indent=4))


@dataclass
class Stage:
    minutes: int
    name: str
    message: str
    seconds_left: int = 0

    @property
    def seconds(self):
        return self.minutes # * 60


@dataclass
class Work(Stage):
    minutes: int = 25
    name: str = 'Work'
    message: str = 'Time to work!'
    icon: str = ''


@dataclass
class ShortBreak(Stage):
    minutes: int = 5
    name: str = 'Short Break'
    message: str = 'Take a short break!'
    icon: str = ''


@dataclass
class LongBreak(Stage):
    minutes: int = 15
    name: str = 'Long Break'
    message: str = 'Take a long break!'
    icon: str = ''


def xrescat(name, default) -> str:
    """In bash: xrescat i3xrocks.value.font "Source Code Pro Medium 13")"""
    return str(call(["xrescat", name, default]))


@dataclass
class Pomo:
    state: Optional[State] = None
    state_fp: str = STATE_FILE
    stages: List[Stage] = (
        Work,
        ShortBreak,
        Work,
        LongBreak,
    )

    @property
    def button(self) -> Optional[int]:
        but = os.environ.get('BLOCK_BUTTON', '').strip()
        return int(but) if but else None

    def run(self):
        # Restore state from JSON
        if self.state is None:
            self.state = State()
            self.state.update_from_json(self.state_fp)

        # Main event loop
        while True:
            self.state.stage = self.state.stage % len(self.stages)
            stage = self.stages[self.state.stage]()
            since_started = self.state.since_started or _now() - self.state.started
            assert since_started >= 0
            remaining = stage.seconds - since_started

            # Stage is over
            if remaining <= 0:
                self.state.stage += 1
                self.state.started = _now()
                notify(stage.message)
                continue

            minutes, seconds = divmod(remaining, 60)
            message = "{0} {1:02d}:{2:02d}".format(stage.icon, minutes, seconds)

            button = self.button
            if button == 1:
                message = f"{button=}"
                if self.state.since_started is None:
                    # Pause
                    self.state.since_started = since_started
                else:
                    # Unpause
                    self.state.started = _now() - self.state.since_started
                    self.state.since_started = None
            emit(message, 'short_text', '#FF8000')

            self.state.to_json(self.state_fp)
            break


def main(state_fp: str = STATE_FILE):
    runner = Pomo(state_fp=state_fp)
    runner.run()


if __name__ == "__main__":
    main(*sys.argv[1:])